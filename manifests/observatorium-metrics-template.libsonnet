// This is the file overwriting and extending the upstream objects to, in the end,
// generate a OpenShift template specifically for AppSRE.

local jaegerAgent = import './sidecars/jaeger-agent.libsonnet';
local oauthProxy = import './sidecars/oauth-proxy.libsonnet';

// TODO(kakkoyun): Find out a higher level functional approach for common label injections.
// e.g. ServiceMonitors
{
  local s3EnvVars = [
    {
      name: 'AWS_ACCESS_KEY_ID',
      valueFrom: {
        secretKeyRef: {
          key: 'aws_access_key_id',
          name: '${THANOS_S3_SECRET}',
        },
      },
    },
    {
      name: 'AWS_SECRET_ACCESS_KEY',
      valueFrom: {
        secretKeyRef: {
          key: 'aws_secret_access_key',
          name: '${THANOS_S3_SECRET}',
        },
      },
    },
  ],

  // JaegerAgent sidecar shared across components, thus instantiated outside components.
  local jaegerAgentSidecar = jaegerAgent({
    image: '${JAEGER_AGENT_IMAGE}:${JAEGER_AGENT_IMAGE_TAG}',
    collectorAddress: 'dns:///jaeger-collector-headless.$(NAMESPACE).svc:14250',

  }),

  // This extends and overwrites the objects generated by the upstream function for OpenShift specific needs.
  compact+:: {
    // Create oauthProxy instance for compact and then merge its objects with the existing ones.
    local oauth = oauthProxy({
      name: 'compact',
      image: '${PROXY_IMAGE}:${PROXY_IMAGE_TAG}',
      upstream: 'http://localhost:10902',
      serviceAccountName: 'prometheus-telemeter',
      sessionSecretName: 'compact-proxy',
      resources: {
        requests: {
          cpu: '${OAUTH_PROXY_CPU_REQUEST}',
          memory: '${OAUTH_PROXY_MEMORY_REQUEST}',
        },
        limits: {
          cpu: '${OAUTH_PROXY_CPU_LIMITS}',
          memory: '${OAUTH_PROXY_MEMORY_LIMITS}',
        },
      },
    }),

    proxySecret: oauth.proxySecret {
      metadata+: {
        labels+: {
          // TODO: Reuse from existing component? Not set at all?
          'app.kubernetes.io/component': 'database-compactor',
          'app.kubernetes.io/instance': 'observatorium',
          'app.kubernetes.io/name': 'thanos-compact',
          'app.kubernetes.io/part-of': 'observatorium',
          'app.kubernetes.io/version': '${THANOS_IMAGE_TAG}',
        },
      },
    },

    service+: oauth.service,

    statefulSet+: oauth.statefulSet {
      spec+: {
        replicas: '${{THANOS_COMPACTOR_REPLICAS}}',
        template+: {
          spec+: {
            containers: [
              // Overwrite and extend the thanos-compact container only
              if c.name == 'thanos-compact' then c {
                env+: s3EnvVars,
                // Temporary workaround on high cardinality blocks for 2w.
                // Since we have only 2w retention, there is no point in having 2w blocks.
                // See: https://issues.redhat.com/browse/OBS-437
                args+: ['--debug.max-compaction-level=3'],
              } else c
              for c in super.containers
            ],
          },
        },
      },
    },
    serviceMonitor+: {
      metadata+: {
        labels+: {
          prometheus: 'app-sre',
          'app.kubernetes.io/version':: 'hidden',
        },
      },
      spec+: {
        namespaceSelector: { matchNames: ['${NAMESPACE}'] },
      },
    },
  },

  rule+:: {
    statefulSet+: jaegerAgentSidecar.statefulSet {
      spec+: {
        replicas: '${{THANOS_RULER_REPLICAS}}',
        template+: {
          spec+: {
            containers: [
              if c.name == 'thanos-rule' then c {
                env+: s3EnvVars,
              } else c
              for c in super.containers
            ],
          },
        },
      },
    },

    serviceMonitor+: {
      metadata+: {
        labels+: {
          prometheus: 'app-sre',
          'app.kubernetes.io/version':: 'hidden',
        },
      },
      spec+: {
        namespaceSelector: { matchNames: ['${NAMESPACE}'] },
      },
    },
  },

  store+::
    std.mapWithKey(function(shard, obj) obj {  // loops over each [shard-n]:obj
      statefulSet+: jaegerAgentSidecar.statefulSet {
        spec+: {
          replicas: '${{THANOS_STORE_REPLICAS}}',
          template+: {
            spec+: {
              containers: [
                if c.name == 'thanos-store' then c {
                  args+: [
                    // TODO: Move this to kube-thanos
                    '--selector.relabel-config=\n' + std.manifestYamlDoc([
                      {
                        action: 'hashmod',
                        source_labels: ['__block_id'],
                        target_label: 'shard',
                        modulus: 3,
                      },
                      {
                        action: 'keep',
                        source_labels: ['shard'],
                        regex: 0,
                      },
                    ]),
                  ],
                  env+: s3EnvVars,
                } else c
                for c in super.containers
              ],
            },
          },
        },
      },
    }, super.store),

  query+:: {
    local oauth = oauthProxy({
      name: 'query',
      image: '${PROXY_IMAGE}:${PROXY_IMAGE_TAG}',
      upstream: 'http://localhost:9090',
      ports: { https: 9091 },
      serviceAccountName: 'prometheus-telemeter',
      sessionSecretName: 'query-proxy',
      resources: {
        requests: {
          cpu: '${OAUTH_PROXY_CPU_REQUEST}',
          memory: '${OAUTH_PROXY_MEMORY_REQUEST}',
        },
        limits: {
          cpu: '${OAUTH_PROXY_CPU_LIMITS}',
          memory: '${OAUTH_PROXY_MEMORY_LIMITS}',
        },
      },
    }),

    proxySecret: oauth.proxySecret,

    service+: oauth.service,

    deployment+: oauth.deployment + jaegerAgentSidecar.deployment {
      spec+: {
        replicas: '${{THANOS_QUERIER_REPLICAS}}',
      },
    },
  },

  queryFrontend+:: {
    local oauth = oauthProxy({
      name: 'query-frontend',
      image: '${PROXY_IMAGE}:${PROXY_IMAGE_TAG}',
      upstream: 'http://localhost:9090',
      ports: { https: 9091 },
      serviceAccountName: 'prometheus-telemeter',
      sessionSecretName: 'query-frontend-proxy',
      resources: {
        requests: {
          cpu: '${OAUTH_PROXY_CPU_REQUEST}',
          memory: '${OAUTH_PROXY_MEMORY_REQUEST}',
        },
        limits: {
          cpu: '${OAUTH_PROXY_CPU_LIMITS}',
          memory: '${OAUTH_PROXY_MEMORY_LIMITS}',
        },
      },
    }),

    proxySecret: oauth.proxySecret,

    service+: oauth.service,

    deployment+: oauth.deployment + jaegerAgentSidecar.deployment {
      spec+: {
        replicas: '${{THANOS_QUERY_FRONTEND_REPLICAS}}',
      },
    },
    serviceMonitor+: {
      metadata+: {
        labels+: {
          prometheus: 'app-sre',
          'app.kubernetes.io/version':: 'hidden',
        },
      },
      spec+: {
        namespaceSelector: { matchNames: ['${NAMESPACE}'] },
      },
    },
  },

  receivers+::
    std.mapWithKey(function(hashring, obj) obj {  // loops over each [hashring]:obj
      statefulSet+: jaegerAgentSidecar.statefulSet {
        spec+: {
          replicas: '${{THANOS_RECEIVE_REPLICAS}}',
          template+: {
            spec+: {
              containers: [
                if c.name == 'thanos-receive' then c {
                  args+: [
                    '--receive.default-tenant-id=FB870BF3-9F3A-44FF-9BF7-D7A047A52F43',
                  ],
                  env+: s3EnvVars + [{
                    name: 'DEBUG',
                    value: '${THANOS_RECEIVE_DEBUG_ENV}',
                  }],
                } + {
                  args: [
                    if std.startsWith(a, '--tsdb.path') then '--tsdb.path=${THANOS_RECEIVE_TSDB_PATH}'
                    else if std.startsWith(a, '--tsdb.retention') then '--tsdb.retention=4d' else a
                    for a in super.args
                  ],
                } else c
                for c in super.containers
              ],
            },
          },
        },
      },
    }, super.receivers),
}
